import json
from typing import Any, Dict, List, NewType, Optional

import frappe
from erpnext.selling.doctype.sales_order.sales_order import make_sales_invoice
from frappe import _
from frappe.utils import cint, flt, nowdate
from frappe.utils.file_manager import save_file

from ecommerce_integrations.ecommerce_integrations.doctype.ecommerce_item import ecommerce_item
from ecommerce_integrations.unicommerce.api_client import UnicommerceAPIClient
from ecommerce_integrations.unicommerce.constants import (
	CHANNEL_ID_FIELD,
	FACILITY_CODE_FIELD,
	INVOICE_CODE_FIELD,
	MODULE_NAME,
	ORDER_CODE_FIELD,
	SETTINGS_DOCTYPE,
	SHIPPING_PACKAGE_CODE_FIELD,
)
from ecommerce_integrations.unicommerce.order import get_taxes
from ecommerce_integrations.unicommerce.utils import create_unicommerce_log, get_unicommerce_date

JsonDict = Dict[str, Any]

SOCode = NewType("SOCode", str)
ItemCode = NewType("ItemCode", str)
WHCode = NewType("WHCode", str)

WHAllocation = Dict[SOCode, Dict[ItemCode, Dict[WHCode, int]]]


@frappe.whitelist()
def generate_unicommerce_invoices(
	sales_orders: List[SOCode], warehouse_allocation: Optional[WHAllocation] = None
):
	"""Request generation of invoice to Unicommerce and sync that invoice.

	1. Get shipping package details using get_sale_order
	2. Ask for invoice generation
	        - marketplace - create_invoice_and_label_by_shipping_code
	        - self-shipped - create_invoice_and_assign_shipper

	3. Sync invoice.

	args:
	        sales_orders: list of sales order codes to invoice.
	        warehouse_allocation: If warehouse is changed while shipping / non-group warehouse is to be assigned then this parameter is required.

	        Example of warehouse_allocation
	        {
	           "SO0042": {
	             "item-1": {
	               "Stores - WP": 1,
	               "WIP Warehouse - WP": 2,
	              },
	             "item-2": {
	               "Stores - WP": 3,
	              }
	           },
	           "SO0101": {
	             "item-x": {
	               "Stores - WP": 8,
	               "WIP Warehouse - WP": 2,
	              }
	           }
	        }
	"""

	if isinstance(sales_orders, str):
		sales_orders = json.loads(sales_orders)

	if isinstance(warehouse_allocation, str):
		warehouse_allocation = json.loads(warehouse_allocation)

	if warehouse_allocation:
		_validate_wh_allocation(warehouse_allocation)

	client = UnicommerceAPIClient()

	for so_code in sales_orders:
		so = frappe.get_doc("Sales Order", so_code)
		channel = so.get(CHANNEL_ID_FIELD)
		channel_config = frappe.get_cached_doc("Unicommerce Channel", channel)
		wh_allocation = warehouse_allocation.get(so_code) if warehouse_allocation else None
		_generate_invoice(client, so, channel_config, warehouse_allocation=wh_allocation)


def _validate_wh_allocation(warehouse_allocation):
	"""Validate that provided warehouse allocation is exactly sufficient for fulfilling the orders."""

	if not warehouse_allocation:
		return
	so_codes = list(warehouse_allocation.keys())
	so_item_data = frappe.db.sql(
		"""
			select item_code, sum(qty) as qty, parent as sales_order
			from `tabSales Order Item`
			where
				parent in %s
			group by parent, item_code""",
		(so_codes,),
		as_dict=True,
	)

	expected_item_qty = {}
	for item in so_item_data:
		expected_item_qty.setdefault(item.sales_order, {})[item.item_code] = item.qty

	for order, item_details in warehouse_allocation.items():
		for item_code, wh_wise_qty in item_details.items():
			total_qty = sum(wh_wise_qty.values())
			expected_qty = expected_item_qty.get(order, {}).get(item_code)

			if abs(total_qty - expected_qty) > 0.1:
				msg = _("Mismatch in quantity for order {}, item {} exepcted {} qty, received {}").format(
					order, item_code, expected_qty, total_qty
				)
				frappe.throw(msg)


def _generate_invoice(
	client: UnicommerceAPIClient, erpnext_order, channel_config, warehouse_allocation=None
):
	unicommerce_so_code = erpnext_order.get(ORDER_CODE_FIELD)

	so_data = client.get_sales_order(unicommerce_so_code)
	shipping_packages = [d["code"] for d in so_data["shippingPackages"] if d["status"] == "CREATED"]

	# TODO:  check if already generated by erpnext invoice unsyced
	facility_code = erpnext_order.get(FACILITY_CODE_FIELD)

	for package in shipping_packages:
		# TODO: error and status logging
		if cint(channel_config.shipping_handled_by_marketplace):
			client.create_invoice_and_label_by_shipping_code(
				shipping_package_code=package, facility_code=facility_code
			)
		else:
			client.create_invoice_and_assign_shipper(
				shipping_package_code=package, facility_code=facility_code
			)

	_fetch_and_sync_invoice(
		client,
		unicommerce_so_code,
		erpnext_order.name,
		facility_code,
		warehouse_allocation=warehouse_allocation,
	)


def _fetch_and_sync_invoice(
	client: UnicommerceAPIClient,
	unicommerce_so_code,
	erpnext_so_code,
	facility_code,
	warehouse_allocation=None,
):
	"""Use the invoice generation response to fetch actual invoice and sync them to ERPNext.

	args:
	        invoice_response: response returned by either of two invoice generation methods
	"""

	so_data = client.get_sales_order(unicommerce_so_code)
	shipping_packages = [
		d["code"] for d in so_data["shippingPackages"] if d["status"] in ("PACKED", "READY_TO_SHIP")
	]

	for package in shipping_packages:
		invoice_data = client.get_sales_invoice(package, facility_code)["invoice"]
		label_pdf = client.get_invoice_label(package, facility_code)
		create_sales_invoice(
			invoice_data,
			erpnext_so_code,
			update_stock=1,
			shipping_label=label_pdf,
			warehouse_allocations=warehouse_allocation,
		)


def create_sales_invoice(
	si_data: JsonDict,
	so_code: str,
	update_stock=0,
	submit=True,
	shipping_label=None,
	warehouse_allocations=None,
):
	"""Create ERPNext Sales Invcoice using Unicommerce sales invoice data and related Sales order.

	Sales Order is required to fetch missing order in the Sales Invoice.
	"""
	so = frappe.get_doc("Sales Order", so_code)
	channel = so.get(CHANNEL_ID_FIELD)
	facility_code = so.get(FACILITY_CODE_FIELD)

	existing_si = frappe.db.get_value("Sales Invoice", {INVOICE_CODE_FIELD: si_data["code"]})
	if existing_si:
		si = frappe.get_doc("Sales Invoice", existing_si)
		create_unicommerce_log(status="Invalid", message="Sales Invoice already exists, skipped")
		return si

	settings = frappe.get_cached_doc(SETTINGS_DOCTYPE)
	channel_config = frappe.get_cached_doc("Unicommerce Channel", channel)

	uni_line_items = si_data["invoiceItems"]
	warehouse = settings.get_integration_to_erpnext_wh_mapping(all_wh=True).get(facility_code)

	if cint(frappe.db.get_value("Warehouse", warehouse, "is_group")) and update_stock:
		# can't submit stock transaction where warehouse is group
		submit = False

	si = make_sales_invoice(so.name)
	si_line_items = _get_line_items(uni_line_items, warehouse, so.name, channel_config.cost_center)
	si.set("items", si_line_items)
	si.set("taxes", get_taxes(uni_line_items, channel_config))
	si.set(INVOICE_CODE_FIELD, si_data["code"])
	si.set(SHIPPING_PACKAGE_CODE_FIELD, si_data.get("shippingPackageCode"))
	si.set_posting_time = 1
	si.posting_date = get_unicommerce_date(si_data["created"])
	si.transaction_date = si.posting_date
	si.naming_series = channel_config.sales_invoice_series or settings.sales_order_series
	si.delivery_date = so.delivery_date
	si.ignore_pricing_rule = 1
	si.update_stock = update_stock
	si.insert()
	if submit:
		si.submit()

	_verify_total(si, si_data)

	attach_unicommerce_docs(
		sales_invoice=si.name,
		invoice=si_data.get("encodedInvoice"),
		label=shipping_label,
		invoice_code=si_data["code"],
		package_code=si_data.get("shippingPackageCode"),
	)

	if cint(channel_config.auto_payment_entry):
		make_payment_entry(si, channel_config, si.posting_date)

	return si


def attach_unicommerce_docs(
	sales_invoice: str,
	invoice: Optional[str],
	label: Optional[str],
	invoice_code: Optional[str],
	package_code: Optional[str],
) -> None:
	"""Attach invoice and label to specified sales invoice.

	Both invoice and label are base64 encoded PDFs.

	File names are generated using specified invoice and shipping package code."""

	if invoice:
		save_file(
			f"unicommerce-invoice-{invoice_code}.pdf",
			invoice,
			"Sales Invoice",
			sales_invoice,
			decode=True,
			is_private=1,
		)

	if label:
		save_file(
			f"unicommerce-label-{package_code}.pdf",
			label,
			"Sales Invoice",
			sales_invoice,
			decode=True,
			is_private=1,
		)


def _get_line_items(
	line_items,
	warehouse: str,
	so_code: str,
	cost_center: str,
	warehouse_allocation: Optional[WHAllocation] = None,
) -> List[Dict[str, Any]]:
	""" Invoice items can be different and are consolidated, hence recomputing is required """

	si_items = []
	for item in line_items:
		item_code = ecommerce_item.get_erpnext_item_code(
			integration=MODULE_NAME, integration_item_code=item["itemSku"]
		)
		si_items.append(
			{
				"item_code": item_code,
				# Note: Discount is already removed from this price.
				"rate": item["unitPrice"],
				"qty": item["quantity"],
				"stock_uom": "Nos",
				"warehouse": warehouse,
				"cost_center": cost_center,
				"sales_order": so_code,
			}
		)
	return si_items


def _verify_total(si, si_data) -> None:
	""" Leave a comment if grand total does not match unicommerce total"""
	if abs(si.grand_total - flt(si_data["total"])) > 0.5:
		si.add_comment(text=f"Invoice totals mismatch: Unicommerce reported total of {si_data['total']}")


def make_payment_entry(invoice, channel_config, invoice_posting_date=None):
	from erpnext.accounts.doctype.payment_entry.payment_entry import get_payment_entry

	payment_entry = get_payment_entry(
		invoice.doctype, invoice.name, bank_account=channel_config.cash_or_bank_account
	)

	payment_entry.reference_no = invoice.get(ORDER_CODE_FIELD) or invoice.name
	payment_entry.posting_date = invoice_posting_date or nowdate()
	payment_entry.reference_date = invoice_posting_date or nowdate()

	payment_entry.insert(ignore_permissions=True)
	payment_entry.submit()
