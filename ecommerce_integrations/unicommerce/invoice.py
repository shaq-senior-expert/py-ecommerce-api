import json
from typing import Any, Dict, List

import frappe
from erpnext.selling.doctype.sales_order.sales_order import make_sales_invoice
from frappe.utils import cint, flt, nowdate
from frappe.utils.file_manager import save_file

from ecommerce_integrations.ecommerce_integrations.doctype.ecommerce_item import ecommerce_item
from ecommerce_integrations.unicommerce.api_client import UnicommerceAPIClient
from ecommerce_integrations.unicommerce.constants import (
	CHANNEL_ID_FIELD,
	FACILITY_CODE_FIELD,
	INVOICE_CODE_FIELD,
	MODULE_NAME,
	ORDER_CODE_FIELD,
	SETTINGS_DOCTYPE,
	SHIPPING_PACKAGE_CODE_FIELD,
)
from ecommerce_integrations.unicommerce.order import get_taxes
from ecommerce_integrations.unicommerce.utils import create_unicommerce_log, get_unicommerce_date

JsonDict = Dict[str, Any]


@frappe.whitelist()
def generate_unicommerce_invoices(sales_orders: List[str]):
	"""Request generation of invoice to Unicommerce and sync that invoice.

	1. Get shipping package details using get_sale_order
	2. Ask for invoice generation
	        - marketplace - create_invoice_and_label_by_shipping_code
	        - self-shipped - create_invoice_and_assign_shipper

	3. Sync invoice.
	"""

	if isinstance(sales_orders, str):
		sales_orders = json.loads(sales_orders)

	client = UnicommerceAPIClient()

	for so_code in sales_orders:
		so = frappe.get_doc("Sales Order", so_code)
		channel = so.get(CHANNEL_ID_FIELD)
		channel_config = frappe.get_cached_doc("Unicommerce Channel", channel)
		_generate_invoice(client, so, channel_config)


def _generate_invoice(client: UnicommerceAPIClient, erpnext_order, channel_config):
	unicommerce_so_code = erpnext_order.get(ORDER_CODE_FIELD)

	so_data = client.get_sales_order(unicommerce_so_code)
	shipping_packages = [d["code"] for d in so_data["shippingPackages"] if d["status"] == "CREATED"]

	# TODO:  check if already generated by erpnext invoice unsyced
	facility_code = erpnext_order.get(FACILITY_CODE_FIELD)

	for package in shipping_packages:
		# TODO: error and status logging
		if cint(channel_config.shipping_handled_by_marketplace):
			client.create_invoice_and_label_by_shipping_code(
				shipping_package_code=package, facility_code=facility_code
			)
		else:
			client.create_invoice_and_assign_shipper(
				shipping_package_code=package, facility_code=facility_code
			)

	_fetch_and_sync_invoice(client, unicommerce_so_code, erpnext_order.name, facility_code)


def _fetch_and_sync_invoice(
	client: UnicommerceAPIClient, unicommerce_so_code, erpnext_so_code, facility_code
):
	"""Use the invoice generation response to fetch actual invoice and sync them to ERPNext.

	args:
	        invoice_response: response returned by either of two invoice generation methods
	"""

	so_data = client.get_sales_order(unicommerce_so_code)
	shipping_packages = [
		d["code"] for d in so_data["shippingPackages"] if d["status"] in ("PACKED", "READY_TO_SHIP")
	]

	for package in shipping_packages:
		invoice_data = client.get_sales_invoice(package, facility_code)["invoice"]
		create_sales_invoice(invoice_data, erpnext_so_code, update_stock=1)


def create_sales_invoice(si_data: JsonDict, so_code: str, update_stock=0, submit=True):
	"""Create ERPNext Sales Invcoice using Unicommerce sales invoice data and related Sales order.

	Sales Order is required to fetch missing order in the Sales Invoice.
	"""
	so = frappe.get_doc("Sales Order", so_code)
	channel = so.get(CHANNEL_ID_FIELD)
	facility_code = so.get(FACILITY_CODE_FIELD)

	existing_si = frappe.db.get_value("Sales Invoice", {INVOICE_CODE_FIELD: si_data["code"]})
	if existing_si:
		si = frappe.get_doc("Sales Invoice", existing_si)
		create_unicommerce_log(status="Invalid", message="Sales Invoice already exists, skipped")
		return si

	settings = frappe.get_cached_doc(SETTINGS_DOCTYPE)
	channel_config = frappe.get_cached_doc("Unicommerce Channel", channel)

	line_items = si_data["invoiceItems"]
	warehouse = settings.get_integration_to_erpnext_wh_mapping(all_wh=True).get(facility_code)

	if cint(frappe.db.get_value("Warehouse", warehouse, "is_group")) and update_stock:
		# can't submit stock transaction where warehouse is group
		submit = False

	si = make_sales_invoice(so.name)
	si.set("items", _get_line_items(line_items, warehouse, so.name, channel_config.cost_center))
	si.set("taxes", get_taxes(line_items, channel_config))
	si.set(INVOICE_CODE_FIELD, si_data["code"])
	si.set(SHIPPING_PACKAGE_CODE_FIELD, si_data.get("shippingPackageCode"))
	si.set_posting_time = 1
	si.posting_date = get_unicommerce_date(si_data["created"])
	si.transaction_date = si.posting_date
	si.naming_series = channel_config.sales_invoice_series or settings.sales_order_series
	si.delivery_date = so.delivery_date
	si.ignore_pricing_rule = 1
	si.update_stock = update_stock
	si.insert()
	if submit:
		si.submit()

	_verify_total(si, si_data)

	if si_data.get("encodedInvoice"):
		# attach file to the sales invoice
		save_file(
			f"unicommerce-invoice-{si_data['code']}.pdf",
			si_data["encodedInvoice"],
			si.doctype,
			si.name,
			decode=True,
			is_private=1,
		)

	if cint(channel_config.auto_payment_entry):
		make_payment_entry(si, channel_config, si.posting_date)

	return si


def _get_line_items(
	line_items, warehouse: str, so_code: str, cost_center: str
) -> List[Dict[str, Any]]:
	""" Invoice items can be different and are consolidated, hence recomputing is required """

	si_items = []
	for item in line_items:
		item_code = ecommerce_item.get_erpnext_item_code(
			integration=MODULE_NAME, integration_item_code=item["itemSku"]
		)
		si_items.append(
			{
				"item_code": item_code,
				# Note: Discount is already removed from this price.
				"rate": item["unitPrice"],
				"qty": item["quantity"],
				"stock_uom": "Nos",
				"warehouse": warehouse,
				"cost_center": cost_center,
				"sales_order": so_code,
			}
		)
	return si_items


def _verify_total(si, si_data) -> None:
	""" Leave a comment if grand total does not match unicommerce total"""
	if abs(si.grand_total - flt(si_data["total"])) > 0.5:
		si.add_comment(text=f"Invoice totals mismatch: Unicommerce reported total of {si_data['total']}")


def make_payment_entry(invoice, channel_config, invoice_posting_date=None):
	from erpnext.accounts.doctype.payment_entry.payment_entry import get_payment_entry

	payment_entry = get_payment_entry(
		invoice.doctype, invoice.name, bank_account=channel_config.cash_or_bank_account
	)

	payment_entry.reference_no = invoice.get(ORDER_CODE_FIELD) or invoice.name
	payment_entry.posting_date = invoice_posting_date or nowdate()
	payment_entry.reference_date = invoice_posting_date or nowdate()

	payment_entry.insert(ignore_permissions=True)
	payment_entry.submit()
